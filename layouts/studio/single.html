{{ define "main" }}

<section class="studio-page-section">
    <div class="container">
        <!-- 헤더 -->
        <div class="studio-page-header">
            <h1>Studio <span>NFP</span></h1>
            <p>디자인 작업을 위한 전문 도구 모음</p>
        </div>

        <!-- 탭 네비게이션 -->
        <div class="studio-page-tabs">
            <div class="studio-page-tab active" data-tab="qr-generator">
                <i class="fas fa-qrcode"></i>
                QR 생성기
                <!-- <span class="studio-new-badge">NEW</span> -->
            </div>
            <div class="studio-page-tab" data-tab="color-palette">
                <i class="fas fa-palette"></i>
                컬러 팔레트
            </div>
            <div class="studio-page-tab" data-tab="color-extractor">
                <i class="fas fa-eye-dropper"></i>
                컬러 추출기
            </div>
            <div class="studio-page-tab" data-tab="size-guide">
                <i class="fas fa-ruler-combined"></i>
                사이즈 가이드
            </div>
            <div class="studio-page-tab" data-tab="design-calculator">
                <i class="fas fa-calculator"></i>
                디자인 계산기
            </div>
        </div>

        <!-- 탭 컨텐츠 -->
        <div class="studio-page-content">
            <!-- QR 생성기 -->
            <div class="studio-tab-panel active" id="qr-generator">
                <h2>QR 코드 생성기</h2>
                <p>URL, 텍스트, 연락처 정보를 QR 코드로 변환하세요</p>
                
                <div class="studio-qr-container">
                    <div>
                        <div class="studio-input-group">
                            <label for="studio-qr-input">변환할 내용</label>
                            <input type="text" id="studio-qr-input" class="studio-form-input" placeholder="URL 또는 텍스트를 입력하세요" value="https://nfpdesign.co.kr">
                        </div>
                        
                        <div class="studio-input-group">
                            <label for="studio-qr-size">QR 코드 크기</label>
                            <select id="studio-qr-size" class="studio-form-input">
                                <option value="200">200x200px</option>
                                <option value="300" selected>300x300px</option>
                                <option value="400">400x400px</option>
                                <option value="500">500x500px</option>
                            </select>
                        </div>
                        
                        <button class="studio-page-btn" onclick="generateQR()">QR 코드 생성</button>
                    </div>
                    
                    <div class="studio-qr-result">
                        <h3>생성된 QR 코드</h3>
                        <canvas id="studio-qr-canvas"></canvas>
                        <button class="studio-page-btn" onclick="downloadQR()" id="studio-download-btn" style="display: none;">다운로드</button>
                    </div>
                </div>
            </div>

            <!-- 컬러 팔레트 -->
            <div class="studio-tab-panel" id="color-palette">
                <h2>컬러 팔레트 생성기</h2>
                <p>다양한 색상 조합과 그라디언트를 생성하세요</p>
                
                <div class="studio-input-group">
                    <label for="studio-base-color">기본 색상</label>
                    <input type="color" id="studio-base-color" class="studio-form-input" value="#01FF75" style="height: 60px;">
                </div>
                
                <div class="studio-input-group">
                    <label for="studio-palette-type">팔레트 타입</label>
                    <select id="studio-palette-type" class="studio-form-input">
                        <option value="monochrome">단색 조합</option>
                        <option value="analogous">유사 색상</option>
                        <option value="complementary">보색 조합</option>
                        <option value="triadic">삼각 조합</option>
                        <option value="gradient">그라디언트</option>
                    </select>
                </div>
                
                <button class="studio-page-btn" onclick="generatePalette()">팔레트 생성</button>
                
                <div class="studio-color-grid" id="studio-palette-result"></div>
            </div>

            <!-- 컬러 추출기 -->
            <div class="studio-tab-panel" id="color-extractor">
                <h2>이미지 컬러 추출기</h2>
                <p>이미지에서 주요 색상을 추출하여 팔레트를 만들어보세요</p>
                
                <div class="studio-upload-area" id="studio-image-upload" onclick="document.getElementById('studio-image-file').click()">
                    <div class="studio-upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <h3>이미지 업로드</h3>
                    <p>클릭하거나 파일을 드래그하여 업로드하세요</p>
                    <input type="file" id="studio-image-file" accept="image/*" style="display: none;">
                </div>
                
                <canvas id="studio-extraction-canvas" style="display: none;"></canvas>
                <div class="studio-color-grid" id="studio-extracted-colors"></div>
            </div>

            <!-- 사이즈 가이드 -->
            <div class="studio-tab-panel" id="size-guide">
                <h2>디자인 사이즈 가이드</h2>
                <p>다양한 플랫폼과 매체의 표준 사이즈를 확인하세요</p>
                
                <div class="studio-size-categories">
                    <div class="studio-size-category">
                        <h3>소셜 미디어</h3>
                        <div class="studio-size-item">
                            <span>인스타그램 포스트</span>
                            <span>1080 x 1080px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>인스타그램 스토리</span>
                            <span>1080 x 1920px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>페이스북 커버</span>
                            <span>820 x 312px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>유튜브 썸네일</span>
                            <span>1280 x 720px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>카카오톡 채널 커버</span>
                            <span>960 x 320px</span>
                        </div>
                    </div>
                    
                    <div class="studio-size-category">
                        <h3>웹사이트</h3>
                        <div class="studio-size-item">
                            <span>데스크톱 헤더</span>
                            <span>1920 x 500px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>모바일 배너</span>
                            <span>375 x 200px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>블로그 포스트</span>
                            <span>1200 x 630px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>파비콘</span>
                            <span>32 x 32px</span>
                        </div>
                        <div class="studio-size-item">
                            <span>OG 이미지</span>
                            <span>1200 x 630px</span>
                        </div>
                    </div>
                    
                    <div class="studio-size-category">
                        <h3>인쇄물</h3>
                        <div class="studio-size-item">
                            <span>A4 용지</span>
                            <span>210 x 297mm</span>
                        </div>
                        <div class="studio-size-item">
                            <span>명함</span>
                            <span>90 x 54mm</span>
                        </div>
                        <div class="studio-size-item">
                            <span>포스터 A3</span>
                            <span>297 x 420mm</span>
                        </div>
                        <div class="studio-size-item">
                            <span>현수막</span>
                            <span>1000 x 700mm</span>
                        </div>
                        <div class="studio-size-item">
                            <span>엽서</span>
                            <span>152 x 102mm</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 디자인 계산기 -->
            <div class="studio-tab-panel" id="design-calculator">
                <h2>디자인 계산기</h2>
                <p>폰트 사이즈, 그리드 시스템 등을 계산하세요</p>
                
                <div class="studio-calculator-grid">
                    <div class="studio-calculator-section">
                        <h3>폰트 크기 계산기</h3>
                        <div class="studio-input-group">
                            <label for="studio-base-font">기본 폰트 크기 (px)</label>
                            <input type="number" id="studio-base-font" class="studio-form-input" value="16">
                        </div>
                        <div class="studio-input-group">
                            <label for="studio-scale-ratio">스케일 비율</label>
                            <select id="studio-scale-ratio" class="studio-form-input">
                                <option value="1.125">Minor Second (1.125)</option>
                                <option value="1.2">Minor Third (1.2)</option>
                                <option value="1.25">Major Third (1.25)</option>
                                <option value="1.333">Perfect Fourth (1.333)</option>
                                <option value="1.414">Augmented Fourth (1.414)</option>
                                <option value="1.5">Perfect Fifth (1.5)</option>
                                <option value="1.618" selected>Golden Ratio (1.618)</option>
                            </select>
                        </div>
                        <button class="studio-page-btn" onclick="calculateFontSizes()">계산하기</button>
                        <div id="studio-font-result" class="studio-calc-result" style="display: none;"></div>
                    </div>
                    
                    <div class="studio-calculator-section">
                        <h3>그리드 계산기</h3>
                        <div class="studio-input-group">
                            <label for="studio-container-width">컨테이너 너비 (px)</label>
                            <input type="number" id="studio-container-width" class="studio-form-input" value="1200">
                        </div>
                        <div class="studio-input-group">
                            <label for="studio-columns">컬럼 수</label>
                            <input type="number" id="studio-columns" class="studio-form-input" value="12">
                        </div>
                        <div class="studio-input-group">
                            <label for="studio-gutter">거터 크기 (px)</label>
                            <input type="number" id="studio-gutter" class="studio-form-input" value="20">
                        </div>
                        <button class="studio-page-btn" onclick="calculateGrid()">계산하기</button>
                        <div id="studio-grid-result" class="studio-calc-result" style="display: none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>


<!--QR 라이브러리 동적 로드 -->
<script>
// QR 라이브러리 동적 로드 함수
function loadQRLibrary() {
    return new Promise((resolve, reject) => {
        // 이미 로드되어 있는지 확인
        if (typeof QRious !== 'undefined') {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        
        // QRious CDN (더 안정적)
        const cdnUrls = [
            'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js',
            'https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js'
        ];
        
        let currentCdnIndex = 0;
        
        function tryLoadFromCdn() {
            if (currentCdnIndex >= cdnUrls.length) {
                console.error('모든 CDN에서 QRious 라이브러리 로드 실패');
                reject();
                return;
            }
            
            const url = cdnUrls[currentCdnIndex];
            
            const newScript = document.createElement('script');
            newScript.src = url;
            newScript.onload = () => {
                resolve();
            };
            newScript.onerror = () => {
                console.error('QRious CDN 로드 실패:', url);
                currentCdnIndex++;
                // 실패한 스크립트 제거
                if (newScript.parentNode) {
                    newScript.parentNode.removeChild(newScript);
                }
                // 다음 CDN 시도
                setTimeout(tryLoadFromCdn, 500);
            };
            
            document.head.appendChild(newScript);
        }
        
        tryLoadFromCdn();
    });
}

// Studio 초기화 함수 (QR 라이브러리 없이도 작동)
function initStudio() {
    
    // 탭 전환 기능
    const tabs = document.querySelectorAll('.studio-page-tab');
    const panels = document.querySelectorAll('.studio-tab-panel');
    
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            
            this.classList.add('active');
            const targetPanel = document.getElementById(this.dataset.tab);
            if (targetPanel) {
                targetPanel.classList.add('active');
            }
        });
    });

    // 이미지 관련 이벤트 설정
    setupImageEvents();
    
    // 컬러 팔레트는 QR 없이도 작동
    generatePalette();
    
   
}

// QR 코드 생성 (라이브러리 로드 확인 포함)
function generateQR() {
    
    if (typeof QRious === 'undefined') {
        return;
    }
    
    
    const input = document.getElementById('studio-qr-input');
    const size = document.getElementById('studio-qr-size');
    const canvas = document.getElementById('studio-qr-canvas');
    
    
    if (!input || !size || !canvas) {
        return;
    }
    
    const inputValue = input.value;
    const sizeValue = parseInt(size.value);
    
    
    try {
        
        const qr = new QRious({
            element: canvas,
            value: inputValue,
            size: sizeValue,
            foreground: '#000000',
            background: '#FFFFFF'
        });
        
        
    } catch (error) {
        throw error; // 에러를 다시 던져서 Promise catch로 전달
    }
}

// QR 코드 다운로드
function downloadQR() {
    const canvas = document.getElementById('studio-qr-canvas');
    if (!canvas) {
        console.error('캔버스를 찾을 수 없습니다.');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = canvas.toDataURL();
    link.click();
}

// 이미지 관련 이벤트 설정
function setupImageEvents() {
    const imageFile = document.getElementById('studio-image-file');
    const uploadArea = document.getElementById('studio-image-upload');
    
    if (imageFile) {
        imageFile.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                extractColorsFromImage(file);
            }
        });
    }

    if (uploadArea) {
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                extractColorsFromImage(files[0]);
            }
        });
    }
}

// 컬러 팔레트 생성
function generatePalette() {
    
    const baseColor = document.getElementById('studio-base-color');
    const type = document.getElementById('studio-palette-type');
    const result = document.getElementById('studio-palette-result');
    
    if (!baseColor || !type || !result) {
        return;
    }
    
    let colors = [];
    const hsl = hexToHsl(baseColor.value);
    
    switch(type.value) {
        case 'monochrome':
            colors = generateMonochrome(hsl);
            break;
        case 'analogous':
            colors = generateAnalogous(hsl);
            break;
        case 'complementary':
            colors = generateComplementary(hsl);
            break;
        case 'triadic':
            colors = generateTriadic(hsl);
            break;
        case 'gradient':
            colors = generateGradient(hsl);
            break;
    }
    
    displayColors(colors, result);
}

// 색상 변환 함수들
function hexToHsl(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return [h * 360, s * 100, l * 100];
}

function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function generateMonochrome(hsl) {
    const colors = [];
    for (let i = 0; i < 5; i++) {
        const lightness = 20 + (i * 20);
        colors.push(hslToHex(hsl[0], hsl[1], lightness));
    }
    return colors;
}

function generateAnalogous(hsl) {
    const colors = [];
    for (let i = -2; i <= 2; i++) {
        const hue = (hsl[0] + i * 30) % 360;
        colors.push(hslToHex(hue, hsl[1], hsl[2]));
    }
    return colors;
}

function generateComplementary(hsl) {
    const colors = [];
    colors.push(hslToHex(hsl[0], hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 180) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.7, hsl[2] * 1.2));
    colors.push(hslToHex((hsl[0] + 180) % 360, hsl[1] * 0.7, hsl[2] * 1.2));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.5, hsl[2] * 0.8));
    return colors;
}

function generateTriadic(hsl) {
    const colors = [];
    colors.push(hslToHex(hsl[0], hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 120) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 240) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.6, hsl[2] * 1.1));
    colors.push(hslToHex((hsl[0] + 120) % 360, hsl[1] * 0.6, hsl[2] * 1.1));
    return colors;
}

function generateGradient(hsl) {
    const colors = [];
    const endHue = (hsl[0] + 60) % 360;
    for (let i = 0; i < 5; i++) {
        const ratio = i / 4;
        const hue = hsl[0] + (endHue - hsl[0]) * ratio;
        const saturation = hsl[1] + (80 - hsl[1]) * ratio;
        const lightness = hsl[2] + (60 - hsl[2]) * ratio;
        colors.push(hslToHex(hue, saturation, lightness));
    }
    return colors;
}

function displayColors(colors, container) {
    if (!container) {
        console.error('컬러 컨테이너를 찾을 수 없습니다.');
        return;
    }
    
    container.innerHTML = '';
    colors.forEach(color => {
        const item = document.createElement('div');
        item.className = 'studio-color-item';
        item.innerHTML = `
            <div class="studio-color-preview" style="background-color: ${color}"></div>
            <div class="studio-color-code">${color}</div>
            <div class="studio-color-code">RGB: ${hexToRgb(color)}</div>
        `;
        item.addEventListener('click', () => {
            navigator.clipboard.writeText(color);
            alert(`${color} 색상 코드가 복사되었습니다!`);
        });
        container.appendChild(item);
    });
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `${r}, ${g}, ${b}`;
}

function extractColorsFromImage(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            const canvas = document.getElementById('studio-extraction-canvas');
            if (!canvas) {
                console.error('추출 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const colors = extractDominantColors(ctx, canvas.width, canvas.height);
            const container = document.getElementById('studio-extracted-colors');
            if (container) {
                displayColors(colors, container);
            }
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function extractDominantColors(ctx, width, height) {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const colorCounts = {};
    
    for (let i = 0; i < data.length; i += 40) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const alpha = data[i + 3];
        
        if (alpha > 128) {
            const color = `${r},${g},${b}`;
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        }
    }
    
    const sortedColors = Object.entries(colorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8)
        .map(([color]) => {
            const [r, g, b] = color.split(',').map(Number);
            return rgbToHex(r, g, b);
        });
    
    return sortedColors;
}

function rgbToHex(r, g, b) {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}

function calculateFontSizes() {
    const baseSize = document.getElementById('studio-base-font');
    const ratio = document.getElementById('studio-scale-ratio');
    const result = document.getElementById('studio-font-result');
    
    if (!baseSize || !ratio || !result) {
        console.error('폰트 계산에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    const baseSizeValue = parseFloat(baseSize.value);
    const ratioValue = parseFloat(ratio.value);
    
    const sizes = {
        'Small': Math.round(baseSizeValue / ratioValue),
        'Body': Math.round(baseSizeValue),
        'H6': Math.round(baseSizeValue * ratioValue),
        'H5': Math.round(baseSizeValue * Math.pow(ratioValue, 2)),
        'H4': Math.round(baseSizeValue * Math.pow(ratioValue, 3)),
        'H3': Math.round(baseSizeValue * Math.pow(ratioValue, 4)),
        'H2': Math.round(baseSizeValue * Math.pow(ratioValue, 5)),
        'H1': Math.round(baseSizeValue * Math.pow(ratioValue, 6))
    };
    
    let html = '<h4>폰트 크기 스케일</h4>';
    for (const [name, size] of Object.entries(sizes)) {
        html += `<div>${name}: ${size}px</div>`;
    }
    
    result.innerHTML = html;
    result.style.display = 'block';
}

function calculateGrid() {
    const containerWidth = document.getElementById('studio-container-width');
    const columns = document.getElementById('studio-columns');
    const gutter = document.getElementById('studio-gutter');
    const result = document.getElementById('studio-grid-result');
    
    if (!containerWidth || !columns || !gutter || !result) {
        console.error('그리드 계산에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    const containerWidthValue = parseInt(containerWidth.value);
    const columnsValue = parseInt(columns.value);
    const gutterValue = parseInt(gutter.value);
    
    const totalGutters = (columnsValue - 1) * gutterValue;
    const availableWidth = containerWidthValue - totalGutters;
    const columnWidth = availableWidth / columnsValue;
    
    let html = '<h4>그리드 계산 결과</h4>';
    html += `<div>컨테이너 너비: ${containerWidthValue}px</div>`;
    html += `<div>컬럼 너비: ${Math.round(columnWidth)}px</div>`;
    html += `<div>거터 크기: ${gutterValue}px</div>`;
    html += `<div>사용 가능한 너비: ${availableWidth}px</div>`;
    
    result.innerHTML = html;
    result.style.display = 'block';
}

// 페이지 로드 시 실행
document.addEventListener('DOMContentLoaded', function() {
    
    // 일단 QR 없이도 작동하는 기능들 먼저 초기화
    initStudio();
    
    // QRious 라이브러리 로드 시도
    loadQRLibrary().then(() => {
    }).catch(() => {
        // QR 기능만 비활성화, 다른 기능은 정상 작동
    });
});
</script> 

<!-- 탭 전환, 탭기능 js -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    
    // 탭 전환 기능
    const tabs = document.querySelectorAll('.studio-page-tab');
    const panels = document.querySelectorAll('.studio-tab-panel');
    
   
    
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            
            this.classList.add('active');
            const targetPanel = document.getElementById(this.dataset.tab);
            if (targetPanel) {
                targetPanel.classList.add('active');
            } else {
            }
        });
    });

    // 이미지 관련 이벤트 등록
    setupImageEvents();
    
});


// 이미지 관련 이벤트 설정
function setupImageEvents() {
    const imageFile = document.getElementById('studio-image-file');
    const uploadArea = document.getElementById('studio-image-upload');
    
    if (imageFile) {
        imageFile.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                extractColorsFromImage(file);
            }
        });
    }

    if (uploadArea) {
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                extractColorsFromImage(files[0]);
            }
        });
    }
}

function generateQR() {
    
    if (typeof QRious === 'undefined') {
        console.error('QRious 라이브러리가 로드되지 않았습니다.');
        return;
    }
    
    const input = document.getElementById('studio-qr-input');
    const size = document.getElementById('studio-qr-size');
    const canvas = document.getElementById('studio-qr-canvas');
    
    if (!input || !size || !canvas) {
        console.error('QR 생성에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    try {
        const qr = new QRious({
            element: canvas,
            value: input.value,
            size: parseInt(size.value)
        });
        
        document.getElementById('studio-download-btn').style.display = 'inline-block';
        
    } catch (error) {
        console.error('QRious 에러:', error);
    }
}

// QR 코드 다운로드
function downloadQR() {
    const canvas = document.getElementById('studio-qr-canvas');
    if (!canvas) {
        console.error('캔버스를 찾을 수 없습니다.');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = canvas.toDataURL();
    link.click();
}

// 컬러 팔레트 생성
function generatePalette() {
    
    const baseColor = document.getElementById('studio-base-color');
    const type = document.getElementById('studio-palette-type');
    const result = document.getElementById('studio-palette-result');
    
    if (!baseColor || !type || !result) {
        console.error('팔레트 생성에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    let colors = [];
    const hsl = hexToHsl(baseColor.value);
    
    switch(type.value) {
        case 'monochrome':
            colors = generateMonochrome(hsl);
            break;
        case 'analogous':
            colors = generateAnalogous(hsl);
            break;
        case 'complementary':
            colors = generateComplementary(hsl);
            break;
        case 'triadic':
            colors = generateTriadic(hsl);
            break;
        case 'gradient':
            colors = generateGradient(hsl);
            break;
    }
    
    displayColors(colors, result);
}

// 나머지 색상 관련 함수들
function hexToHsl(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return [h * 360, s * 100, l * 100];
}

function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function generateMonochrome(hsl) {
    const colors = [];
    for (let i = 0; i < 5; i++) {
        const lightness = 20 + (i * 20);
        colors.push(hslToHex(hsl[0], hsl[1], lightness));
    }
    return colors;
}

function generateAnalogous(hsl) {
    const colors = [];
    for (let i = -2; i <= 2; i++) {
        const hue = (hsl[0] + i * 30) % 360;
        colors.push(hslToHex(hue, hsl[1], hsl[2]));
    }
    return colors;
}

function generateComplementary(hsl) {
    const colors = [];
    colors.push(hslToHex(hsl[0], hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 180) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.7, hsl[2] * 1.2));
    colors.push(hslToHex((hsl[0] + 180) % 360, hsl[1] * 0.7, hsl[2] * 1.2));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.5, hsl[2] * 0.8));
    return colors;
}

function generateTriadic(hsl) {
    const colors = [];
    colors.push(hslToHex(hsl[0], hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 120) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex((hsl[0] + 240) % 360, hsl[1], hsl[2]));
    colors.push(hslToHex(hsl[0], hsl[1] * 0.6, hsl[2] * 1.1));
    colors.push(hslToHex((hsl[0] + 120) % 360, hsl[1] * 0.6, hsl[2] * 1.1));
    return colors;
}

function generateGradient(hsl) {
    const colors = [];
    const endHue = (hsl[0] + 60) % 360;
    for (let i = 0; i < 5; i++) {
        const ratio = i / 4;
        const hue = hsl[0] + (endHue - hsl[0]) * ratio;
        const saturation = hsl[1] + (80 - hsl[1]) * ratio;
        const lightness = hsl[2] + (60 - hsl[2]) * ratio;
        colors.push(hslToHex(hue, saturation, lightness));
    }
    return colors;
}

function displayColors(colors, container) {
    if (!container) {
        console.error('컬러 컨테이너를 찾을 수 없습니다.');
        return;
    }
    
    container.innerHTML = '';
    colors.forEach(color => {
        const item = document.createElement('div');
        item.className = 'studio-color-item';
        item.innerHTML = `
            <div class="studio-color-preview" style="background-color: ${color}"></div>
            <div class="studio-color-code">${color}</div>
            <div class="studio-color-code">RGB: ${hexToRgb(color)}</div>
        `;
        item.addEventListener('click', () => {
            navigator.clipboard.writeText(color);
            alert(`${color} 색상 코드가 복사되었습니다!`);
        });
        container.appendChild(item);
    });
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `${r}, ${g}, ${b}`;
}

function extractColorsFromImage(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            const canvas = document.getElementById('studio-extraction-canvas');
            if (!canvas) {
                console.error('추출 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const colors = extractDominantColors(ctx, canvas.width, canvas.height);
            const container = document.getElementById('studio-extracted-colors');
            if (container) {
                displayColors(colors, container);
            }
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function extractDominantColors(ctx, width, height) {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const colorCounts = {};
    
    for (let i = 0; i < data.length; i += 40) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const alpha = data[i + 3];
        
        if (alpha > 128) {
            const color = `${r},${g},${b}`;
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        }
    }
    
    const sortedColors = Object.entries(colorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8)
        .map(([color]) => {
            const [r, g, b] = color.split(',').map(Number);
            return rgbToHex(r, g, b);
        });
    
    return sortedColors;
}

function rgbToHex(r, g, b) {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}

function calculateFontSizes() {
    const baseSize = document.getElementById('studio-base-font');
    const ratio = document.getElementById('studio-scale-ratio');
    const result = document.getElementById('studio-font-result');
    
    if (!baseSize || !ratio || !result) {
        console.error('폰트 계산에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    const baseSizeValue = parseFloat(baseSize.value);
    const ratioValue = parseFloat(ratio.value);
    
    const sizes = {
        'Small': Math.round(baseSizeValue / ratioValue),
        'Body': Math.round(baseSizeValue),
        'H6': Math.round(baseSizeValue * ratioValue),
        'H5': Math.round(baseSizeValue * Math.pow(ratioValue, 2)),
        'H4': Math.round(baseSizeValue * Math.pow(ratioValue, 3)),
        'H3': Math.round(baseSizeValue * Math.pow(ratioValue, 4)),
        'H2': Math.round(baseSizeValue * Math.pow(ratioValue, 5)),
        'H1': Math.round(baseSizeValue * Math.pow(ratioValue, 6))
    };
    
    let html = '<h4>폰트 크기 스케일</h4>';
    for (const [name, size] of Object.entries(sizes)) {
        html += `<div>${name}: ${size}px</div>`;
    }
    
    result.innerHTML = html;
    result.style.display = 'block';
}

function calculateGrid() {
    const containerWidth = document.getElementById('studio-container-width');
    const columns = document.getElementById('studio-columns');
    const gutter = document.getElementById('studio-gutter');
    const result = document.getElementById('studio-grid-result');
    
    if (!containerWidth || !columns || !gutter || !result) {
        console.error('그리드 계산에 필요한 요소를 찾을 수 없습니다.');
        return;
    }
    
    const containerWidthValue = parseInt(containerWidth.value);
    const columnsValue = parseInt(columns.value);
    const gutterValue = parseInt(gutter.value);
    
    const totalGutters = (columnsValue - 1) * gutterValue;
    const availableWidth = containerWidthValue - totalGutters;
    const columnWidth = availableWidth / columnsValue;
    
    let html = '<h4>그리드 계산 결과</h4>';
    html += `<div>컨테이너 너비: ${containerWidthValue}px</div>`;
    html += `<div>컬럼 너비: ${Math.round(columnWidth)}px</div>`;
    html += `<div>거터 크기: ${gutterValue}px</div>`;
    html += `<div>사용 가능한 너비: ${availableWidth}px</div>`;
    
    result.innerHTML = html;
    result.style.display = 'block';
}
</script>

{{ end }}